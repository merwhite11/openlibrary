#! /usr/bin/env python
"""Run affiliate server.

Usage:

start affiliate-server using dev webserver:

    ./scripts/affiliate-server openlibrary.yml 31337

start affiliate-server as fastcgi:

    ./scripts/affiliate-server openlibrary.yml fastcgi 31337

start affiliate-server using gunicorn webserver:

    ./scripts/affiliate-server openlibrary.yml --gunicorn -b 0.0.0.0:31337

"""

import json
import logging
import os
import sys
import time
import web
import yaml

from openlibrary.core import cache
from openlibrary.core.vendors import AmazonAPI
from openlibrary.utils.isbn import (
    normalize_isbn, isbn_13_to_isbn_10, isbn_10_to_isbn_13)
from openlibrary.utils.dateutil import DAY_SECS
import _init_path

logger = logging.getLogger("affiliate-server")

urls = (
    '/isbn/([0-9X-]+)', 'Submit'
)

class Submit:

    @classmethod
    def unpack_isbn(cls, isbn):
        isbn = normalize_isbn(isbn)
        isbn10 = isbn if len(isbn) == 10 else isbn.startswith('978') and isbn_13_to_isbn_10(isbn)
        isbn13 = isbn if len(isbn) == 13 else isbn_10_to_isbn_13(isbn)
        return isbn10, isbn13


    def GET(self, isbn, threshold=4, wait=3):
        """
        If the threshold is met, piggy back request and do an amazon lookup to fill cache.
        Next, check if solution is in cache. If so, return it.
        Otherwise, return the equivalent of a promise e.g. "submitted"

        Wait until queue exceeds threshold length or until wait period
        exceededed (i.e. wait seconds passed)
        """

        if not web.amazon_api:
            return json.dumps({"error": "not_configured"})

        isbn10, isbn13 = self.unpack_isbn(isbn)
        if not (isbn10 and isbn13):
            return json.dumps({
                "error": "rejected_isbn",
                "isbn10": isbn10,
                "isbn13": isbn13
            })

        # Cache lookup by isbn13. If there's a miss, add to queue
        if not cache.memcache_cache.get('amazon_product_%s' % isbn13):
            # Misses (which will get submitted to amz as ASIN) are isbn10
            # We should track when (queue % 20) occurs
            web.amazon_queue.add(isbn10)

        threshold_passed = len(web.amazon_queue) > threshold
        timer_passed = time.time() + wait > web.amazon_timer
        if len(web.amazon_queue) and (threshold_passed or timer_passed):
            # amz has a limit of 10 IDs but the queue may have more than 10 ids
            # so we should only pop 10 items off the queue and keep the rest on
            queue = list(web.amazon_queue)
            web.amazon_queue = set(queue[10:])
            try:
                products = web.amazon_api.get_products(queue[:10], serialize=True)
                for product in products:
                    # Make sure we have an isbn13 for cache key
                    cache_key = (
                        product.get('isbn_13') and product.get('isbn_13')[0] or 
                        isbn_10_to_isbn_13(product.get('isbn_10')[0])
                    )
                    cache.memcache_cache.set(
                        'amazon_product_%s' % cache_key, product, expires=DAY_SECS)
                # Reset the amazon timer
                web.amazon_timer = time.time()
            except Exception:
                logger.exception("amazon_api.get_product({}, serialize=True)".format(queue))                
                web.amazon_queue.update(queue)  # Careful, request may enter fail-loop from bad IDs

        return json.dumps({
            "status": "success",
            "hit": cache.memcache_cache.get('amazon_product_%s' % isbn13)
        } if cache.memcache_cache.get('amazon_product_%s' % isbn13) else {
            "status": "submitted",
            "queue": len(web.amazon_queue),
            "threshold": threshold,
            "timer": web.amazon_timer
        })

def load_config(configfile):
    with open(configfile) as in_file:
        d = yaml.safe_load(in_file)
    for k, v in d.items():
        setattr(web.ol_config, k, v)

    if 'fastcgi' in d:
        web.config.fastcgi = d['fastcgi']

    web.amazon_api = None
    args = [
        web.ol_config.amazon_api.get('key'),
        web.ol_config.amazon_api.get('secret'),
        web.ol_config.amazon_api.get('id')
    ]
    if all(args):
        web.amazon_api = AmazonAPI(*args, throttling=0.9)
        web.amazon_queue = set()
        web.amazon_timer = time.time()
        logger.exception("Initializing AmazonAPI")


def init_sentry(app):
    from openlibrary.utils.sentry import Sentry
    sentry = Sentry(getattr(web.ol_config, 'sentry', {}))
    if sentry.enabled:
        sentry.init()
        sentry.bind_to_webpy_app(app)

def setup_env():
    # make sure PYTHON_EGG_CACHE is writable
    os.environ['PYTHON_EGG_CACHE'] = "/tmp/.python-eggs"

    # required when run as fastcgi
    os.environ['REAL_SCRIPT_NAME'] = ""

def start_server():
    sysargs = sys.argv[1:]
    configfile, args = sysargs[0], sysargs[1:]

    # type: (str) -> None
    load_config(configfile)

    # sentry could be loaded here
    # init_sentry(app)

    sys.argv = [sys.argv[0]] + list(args)
    app.run()
    
def start_gunicorn_server():
    """Starts the affiliate server using gunicorn server.
    """
    from gunicorn.app.base import Application
    
    configfile = sys.argv.pop(1)
    
    class WSGIServer(Application):
        def init(self, parser, opts, args):
            pass
            
        def load(self):
            load_config(configfile)
            # init_setry(app)
            return app.wsgifunc(https_middleware)
            
    WSGIServer("%prog openlibrary.yml --gunicorn [options]").run()


def https_middleware(app):
    """Hack to support https even when the app server http only.

    The nginx configuration has changed to add the following setting:

        proxy_set_header X-Scheme $scheme;

    Using that value to overwrite wsgi.url_scheme in the WSGI environ,
    which is used by all redirects and other utilities.
    """
    def wrapper(environ, start_response):
        if environ.get('HTTP_X_SCHEME') == 'https':
            environ['wsgi.url_scheme'] = 'https'
        return app(environ, start_response)
    return wrapper


def runfcgi(func, addr=('localhost', 8000)):
    """Runs a WSGI function as a FastCGI pre-fork server."""
    config = dict(web.config.get("fastcgi", {}))

    mode = config.pop("mode", None)
    if mode == "prefork":
        import flup.server.fcgi_fork as flups
    else:
        import flup.server.fcgi as flups

    return flups.WSGIServer(func, multiplexed=True, bindAddress=addr, **config).run()


web.ol_config = web.storify({})
web.config.debug = False
web.wsgi.runfcgi = runfcgi

app = web.application(urls, locals())

    
if __name__ == "__main__":
    setup_env()
    if "--gunicorn" in sys.argv:
        sys.argv.pop(sys.argv.index("--gunicorn"))        
        start_gunicorn_server()
    else:
        start_server()
