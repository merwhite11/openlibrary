#! /usr/bin/env python
"""Run affiliate server.

Usage:

start affiliate-server using dev webserver:

    ./scripts/affiliate-server openlibrary.yml 31337

start affiliate-server as fastcgi:

    ./scripts/affiliate-server openlibrary.yml fastcgi 31337

start affiliate-server using gunicorn webserver:

    ./scripts/affiliate-server openlibrary.yml --gunicorn -b 0.0.0.0:31337

"""

import json
import logging
import os
import queue
import sys
import threading
import time

import web
import yaml

import _init_path
from openlibrary.core import cache
from openlibrary.core.vendors import AmazonAPI
from openlibrary.utils.dateutil import DAY_SECS
from openlibrary.utils.isbn import (
    normalize_isbn, isbn_13_to_isbn_10, isbn_10_to_isbn_13)

logger = logging.getLogger("affiliate-server")

urls = (
    '/isbn/([0-9X-]+)', 'Submit'
)

API_MAX_ITEMS_PER_CALL = 10
API_MAX_WAIT_SECONDS = 3

web.amazon_queue = queue.Queue()


def process_batch(batch):
    logger.info("process_amazon_batch(): {} items".format(len(batch)))
    try:
        products = web.amazon_api.get_products(batch, serialize=True)
    except Exception:
        logger.exception("amazon_api.get_product({}, serialize=True)".format(batch))
    for product in products:
        # Make sure we have an isbn13 for cache key
        cache_key = (
            product.get('isbn_13') and product.get('isbn_13')[0] or
            isbn_10_to_isbn_13(product.get('isbn_10')[0])
        )
        cache.memcache_cache.set(
            'amazon_product_%s' % cache_key, product, expires=DAY_SECS
        )


def seconds_remaining(start_time):
    return max(API_MAX_WAIT_SECONDS - (time.time() - start_time), 0)


def amazon_lookup():
    """
    A separate thread of execution that waits until API_THROTTLE_SECONDS
    """
    while True:
        start_time = time.time()
        batch = set()  # no duplicates
        while len(batch) < API_MAX_ITEMS_PER_CALL and seconds_remaining(start_time):
            try:
                batch.add(web.amazon_queue.get(timeout=seconds_remaining(start_time)))
            except queue.Empty:
                pass
        if batch:
            time.sleep(seconds_remaining(start_time))
            process_amazon_batch(list(batch))


threading.Thread(target=amazon_lookup).start()


class Submit:

    @classmethod
    def unpack_isbn(cls, isbn):
        isbn = normalize_isbn(isbn.replace('-', ''))
        isbn10 = isbn if len(isbn) == 10 else isbn.startswith('978') and isbn_13_to_isbn_10(isbn)
        isbn13 = isbn if len(isbn) == 13 else isbn_10_to_isbn_13(isbn)
        return isbn10, isbn13


    def GET(self, isbn, threshold=4, wait=3):
        """
        If the threshold is met, piggy back request and do an amazon lookup to fill cache.
        Next, check if solution is in cache. If so, return it.
        Otherwise, return the equivalent of a promise e.g. "submitted"

        Wait until queue exceeds threshold length or until wait period
        exceeded (i.e. wait seconds passed)
        """
        if not web.amazon_api:
            return json.dumps({"error": "not_configured"})

        isbn10, isbn13 = self.unpack_isbn(isbn)
        if not isbn10 and not isbn13:
            return json.dumps({
                "error": "rejected_isbn",
                "isbn10": isbn10,
                "isbn13": isbn13
            })

        # Cache lookup by isbn13. If there's a hit return the product to the caller
        product = cache.memcache_cache.get('amazon_product_%s' % isbn13)
        if product:
            return json.dumps({"status": "success", "hit": product})

        # Cache misses will be submitted to Amazon as ASINs (isbn10)
        web.amazon_queue.put_nowait(isbn10)
        return json.dumps({
            "status": "submitted",
            "queue": web.amazon_queue.qsize(),
        })


def load_config(configfile):
    with open(configfile) as in_file:
        d = yaml.safe_load(in_file)
    for k, v in d.items():
        setattr(web.ol_config, k, v)

    if 'fastcgi' in d:
        web.config.fastcgi = d['fastcgi']

    web.amazon_api = None
    args = [
        web.ol_config.amazon_api.get('key'),
        web.ol_config.amazon_api.get('secret'),
        web.ol_config.amazon_api.get('id')
    ]
    if all(args):
        web.amazon_api = AmazonAPI(*args, throttling=0.9)
        web.amazon_queue = set()
        web.amazon_timer = time.time()
        logger.exception("Initializing AmazonAPI")


def init_sentry(app):
    from openlibrary.utils.sentry import Sentry
    sentry = Sentry(getattr(web.ol_config, 'sentry', {}))
    if sentry.enabled:
        sentry.init()
        sentry.bind_to_webpy_app(app)

def setup_env():
    # make sure PYTHON_EGG_CACHE is writable
    os.environ['PYTHON_EGG_CACHE'] = "/tmp/.python-eggs"

    # required when run as fastcgi
    os.environ['REAL_SCRIPT_NAME'] = ""

def start_server():
    sysargs = sys.argv[1:]
    configfile, args = sysargs[0], sysargs[1:]

    # type: (str) -> None
    load_config(configfile)

    # sentry could be loaded here
    # init_sentry(app)

    sys.argv = [sys.argv[0]] + list(args)
    app.run()

def start_gunicorn_server():
    """Starts the affiliate server using gunicorn server.
    """
    from gunicorn.app.base import Application

    configfile = sys.argv.pop(1)

    class WSGIServer(Application):
        def init(self, parser, opts, args):
            pass

        def load(self):
            load_config(configfile)
            # init_setry(app)
            return app.wsgifunc(https_middleware)

    WSGIServer("%prog openlibrary.yml --gunicorn [options]").run()


def https_middleware(app):
    """Hack to support https even when the app server http only.

    The nginx configuration has changed to add the following setting:

        proxy_set_header X-Scheme $scheme;

    Using that value to overwrite wsgi.url_scheme in the WSGI environ,
    which is used by all redirects and other utilities.
    """
    def wrapper(environ, start_response):
        if environ.get('HTTP_X_SCHEME') == 'https':
            environ['wsgi.url_scheme'] = 'https'
        return app(environ, start_response)
    return wrapper


def runfcgi(func, addr=('localhost', 8000)):
    """Runs a WSGI function as a FastCGI pre-fork server."""
    config = dict(web.config.get("fastcgi", {}))

    mode = config.pop("mode", None)
    if mode == "prefork":
        import flup.server.fcgi_fork as flups
    else:
        import flup.server.fcgi as flups

    return flups.WSGIServer(func, multiplexed=True, bindAddress=addr, **config).run()


web.ol_config = web.storify({})
web.config.debug = False
web.wsgi.runfcgi = runfcgi

app = web.application(urls, locals())


if __name__ == "__main__":
    setup_env()
    if "--gunicorn" in sys.argv:
        sys.argv.pop(sys.argv.index("--gunicorn"))    
        start_gunicorn_server()
    else:
        start_server()
