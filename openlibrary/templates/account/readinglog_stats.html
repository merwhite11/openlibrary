$def with (works_json, authors_json)

$jsdef render_excluded_works_list(works):
    <details>
        <summary>$len(works) works excluded due to missing data</summary>
        <ul>
        $for work in works:
            <li><a href="$work.key" style="font-style:oblique">$work.title</a>
                $ first_publish_year = work.first_publish_year or '????'
                <span title="First published in $first_publish_year">($first_publish_year)</span>
                by
                $for author in work.authors:
                    <a href="$author.key">$author.name</a>
                    $if not loop.last:
                        ,
            </li>
        </ul>
    </details>

<h2>$_('Author Stats')</h2>

<h3>$_('Most Read Authors')</h3>
<div class="readinglog-stats-chart" id="author-name"></div>

<h3>$_('Works by Author Sex')</h3>
<div class="readinglog-stats-chart" id="author-sex"></div>

<h3>$_('Works by Author Ethnicity')</h3>
<div class="readinglog-stats-chart" id="author-ethnic-group"></div>

<h3>$_('Works by Author Country of Citizenship')</h3>
<div class="readinglog-stats-chart" id="author-country-of-citizenship"></div>

<h3>$_('Works by Author Country of Birth')</h3>
<div class="readinglog-stats-chart" id="author-country-of-birth"></div>

<h2>$_('Work Stats')</h2>

<h3>$_('Works by Subject')</h3>
<div class="readinglog-stats-chart" id="work-subjects"></div>

<h3>$_('Works by People')</h3>
<div class="readinglog-stats-chart" id="work-subject-people"></div>

<h3>$_('Works by Places')</h3>
<div class="readinglog-stats-chart" id="work-subject-places"></div>

<h3>$_('Works by Time Period')</h3>
<div class="readinglog-stats-chart" id="work-subject-times"></div>


<script type="module">
    import 'https://unpkg.com/lodash@4.17.15/lodash.js';
    import 'https://unpkg.com/chart.js@2.9.3/dist/Chart.js';
    window.Chart = Chart;
    window._ = _;
    const config = {
        works: $:works_json,
        authors: $:authors_json,
        charts: [
            { id: 'work-subjects', type: 'work-chart', key: 'subjects', exclude: ['Accessible book', 'Protected DAISY', 'In library', 'Lending library'] },
            { id: 'work-subject-people', type: 'work-chart', key: 'subject_people' },
            { id: 'work-subject-places', type: 'work-chart', key: 'subject_places' },
            { id: 'work-subject-times', type: 'work-chart', key: 'subject_times' },
            { id: 'author-name', type: 'work-chart', key: 'authors[].name' },
            { id: 'author-sex', type: 'wd-chart', key: 'authors[].wd.sexLabel[].value' },
            { id: 'author-ethnic-group', type: 'wd-chart', key: 'authors[].wd.ethnic_groupLabel[].value' },
            { id: 'author-country-of-citizenship', type: 'wd-chart', key: 'authors[].wd.country_of_citizenshipLabel[].value' },
            { id: 'author-country-of-birth', type: 'wd-chart', key: 'authors[].wd.country_of_birthLabel[].value' },
        ],
    };
    window.config = config;
    Chart.scaleService.updateScaleDefaults('linear', { ticks: { beginAtZero: true, stepSize: 1 } });
    const authors_by_id = _.fromPairs(config.authors.map(a => [a.key, a]));

    function getPath(obj, key) {
        function main(obj, [head, ...rest]) {
            if (typeof(obj) == 'undefined') return undefined;
            if (!head) return obj;
            if (head.endsWith('[]')) return obj[head.slice(0, -2)].flatMap(x => main(x, rest));
            else return main(obj[head], rest);
        }
        return main(obj, key.split('.'));
    }

    function createWorkChart(config, chartConfig, container, canvas) {
        const grouped = {};
        const excluded = [];
        for (const work of config.works) {
            const item = getPath(work, chartConfig.key);
            if (!item || !item.filter(x => !_.isUndefined(x) && !_.includes(chartConfig.exclude, x)).length) {
                excluded.push(work);
                continue;
            }
            for (const s of item.filter(x => !_.isUndefined(x) && !_.includes(chartConfig.exclude, x))) {
                grouped[s] = grouped[s] || [];
                grouped[s].push(work);
            }
        }

        const bars = _.orderBy(_.entries(grouped), x => x[1].length, 'desc');
        const chart = new Chart(canvas.getContext('2d'), {
            type: 'horizontalBar',
            data: {
                labels: bars.map(b => b[0]),
                datasets: [{
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    data: bars.map(b => b[1].length)
                }]
            },
            options: {
                scales: {
                    xAxis: [{
                        gridLines: { display: false }
                    }],
                    yAxis: [{
                        position: 'top',
                        ticks: { beginAtZero: true, stepSize: 1 }
                    }]
                },
                legend: { display: false }
            }
        });

        $$(render_excluded_works_list(excluded)).appendTo(container);
    }

    const SPARQL_FIELDS = [
        { name: 'ethnic_group', type: 'uri', relation: 'wdt:P172' },
        { name: 'sex', type: 'uri', relation: 'wdt:P21' },
        { name: 'dob', type: 'literal', relation: 'wdt:P569' },
        { name: 'country_of_citizenship', type: 'uri', relation: 'wdt:P27' },
        { name: 'country_of_birth', type: 'uri', relation: 'wdt:P19/wdt:P131*/wdt:P17' },
    ]
    const sparql = `
SELECT DISTINCT ?x ?xLabel ?olid
    $${
        SPARQL_FIELDS.map(f => `?$${f.name} ` + (f.type == 'uri' ? `?$${f.name}Label ` : '')).join('')
    }
WHERE {
  VALUES ?olids { $${config.authors.map(a => `"$${a.key.split('/')[2]}"`).join(' ')} }
  ?x wdt:P648 ?olids;
     wdt:P648 ?olid.

  $${
    SPARQL_FIELDS.map(f => `OPTIONAL { ?x $${f.relation} ?$${f.name}. }`)
    .join('\n')
  }

  SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
}
`;

    const wdPromise = fetch('https://query.wikidata.org/sparql?format=json', {
        method: 'POST',
        body: new URLSearchParams({query: sparql})
    })
    .then(r => r.json())
    .then(resp => {
        const bindings = resp.results.bindings;
        console.log(resp);
        const grouped = _.groupBy(bindings, o => o.x.value.split('/')[4]);
        const records = _.entries(grouped).map(([qid, bindings]) => {
            const record = { qid, olids: _.uniq(bindings.map(x => x.olid.value)) };
            // { qid: Q123, olids: [ { value: }, {value: }], blah: [ {value:}, {value:} ], blahLabel: [{value:}, {value:},
            for (const {name, type} of SPARQL_FIELDS) {
                if (type == 'uri') {
                    // need to dedupe whilst keeping labels in mind
                    const deduped = _.uniqBy(
                        bindings
                        .filter(x => x[name])
                        .map(x => ({ [name]: x[name], [name + 'Label']: x[name + 'Label'] })),
                        x => x[name].value)
                    record[name] = deduped.map(x => x[name]);
                    record[name + 'Label'] = deduped.map(x => x[name + 'Label']);
                } else {
                    record[name] = _.uniqBy(bindings.map(x => x[name]), 'value');
                }
            }
            return record;
        });
        console.log(records);
        for (const record of records) {
            for (const olid of record.olids) {
                if (`/authors/$${olid}` in authors_by_id) {
                    authors_by_id[`/authors/$${olid}`].wd = record;
                }
            }
        }
    });

    // Add full authors to the works objects for easy reference
    for (const work of config.works) {
        work.authors = work.author_keys.map(key => authors_by_id[key]);
    }

    for (const chartConfig of config.charts) {
        const container = document.getElementById(chartConfig.id);
        const canvas = document.createElement('canvas');
        container.append(canvas);

        if (chartConfig.type == 'work-chart') {
            createWorkChart(config, chartConfig, container, canvas);
        } else if (chartConfig.type == 'wd-chart') {
            wdPromise.then(() => createWorkChart(config, chartConfig, container, canvas));
        }
    }
</script>
